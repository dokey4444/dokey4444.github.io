<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Linux进程调度 | 子谋的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Linux进程分类交互式进程此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。 批处理进程此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。 实时进程实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件 内">
<meta name="keywords" content="Linux,Scheduling">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux进程调度">
<meta property="og:url" content="http://yoursite.com/2018/01/12/linux-process-scheduling/index.html">
<meta property="og:site_name" content="子谋的技术博客">
<meta property="og:description" content="Linux进程分类交互式进程此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。 批处理进程此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。 实时进程实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件 内">
<meta property="og:updated_time" content="2018-01-11T05:09:17.268Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux进程调度">
<meta name="twitter:description" content="Linux进程分类交互式进程此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。 批处理进程此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。 实时进程实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件 内">
  
    <link rel="alternate" href="/atom.xml" title="子谋的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">子谋的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Elwin.Gao&#39;s TechBlog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux-process-scheduling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/linux-process-scheduling/" class="article-date">
  <time datetime="2018-01-12T01:00:00.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux进程调度
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux进程分类"><a href="#Linux进程分类" class="headerlink" title="Linux进程分类"></a>Linux进程分类</h1><h3 id="交互式进程"><a href="#交互式进程" class="headerlink" title="交互式进程"></a>交互式进程</h3><p>此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。</p>
<h3 id="批处理进程"><a href="#批处理进程" class="headerlink" title="批处理进程"></a>批处理进程</h3><p>此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。</p>
<h3 id="实时进程"><a href="#实时进程" class="headerlink" title="实时进程"></a>实时进程</h3><p>实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件</p>
<h1 id="内核调度器的演变"><a href="#内核调度器的演变" class="headerlink" title="内核调度器的演变"></a>内核调度器的演变</h1><h2 id="Linux2-4-的调度器"><a href="#Linux2-4-的调度器" class="headerlink" title="Linux2.4 的调度器"></a>Linux2.4 的调度器</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><pre><code>RunQueue + 时间片 + 优先级
</code></pre><p>对 runqueue（全局唯一的就绪队列） 中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。<br>每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。<br>Linux2.4 调度器保证只有当所有 RUNNING 进程的时间片都被用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行。</p>
<h4 id="实时进程-1"><a href="#实时进程-1" class="headerlink" title="实时进程"></a>实时进程</h4><pre><code>静态优先级
</code></pre><p>实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当 runqueue 中没有实时进程的情况下，普通进程才能够获得调度。<br>实时进程采用两种调度策略：</p>
<ul>
<li>SCHED_FIFO采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度</li>
<li>SCHED_RR(Round Robin) 采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。</li>
</ul>
<h4 id="普通进程"><a href="#普通进程" class="headerlink" title="普通进程"></a>普通进程</h4><pre><code>counter（时间片）越大，优先级越高
</code></pre><p>普通进程的优先级主要由进程描述符中的 Counter 字段决定 (还要加上 nice 设定的静态优先级) 。<br>nice从最初的UNIX沿用而来，表示进程的静态负向优先级，其取值范围为19~-20，以-20优先级最高。<br>进程被创建时子进程的 counter 值为父进程 counter 值的一半，这样保证了任何进程不能依靠不断地 fork() 子进程从而获得更多的执行机会。<br>当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。系统通过这种方式提高交互式进程的相应速度。</p>
<h3 id="调度算法的优缺点"><a href="#调度算法的优缺点" class="headerlink" title="调度算法的优缺点"></a>调度算法的优缺点</h3><ul>
<li>可扩展性不好：无论pick next，还是更新counter，系统开销都是根据进程数线性增长</li>
<li>高负载系统上的调度性能比较低：2.4的调度器预分配给每个进程的时间片比较大，这就导致了在高负载系统上，任何一个进程被调度到通常至少要等待一个时间片（一般是10ms）</li>
<li>交互式进程的优化并不完善：无法区分IO等待和交互等待，当系统进行IO密集型作业时，由于大量的IO等待，这些作业虽然不是交互式作业，但依旧被提高了优先级，从而影响到真正的交互式作业。</li>
<li>对实时进程的支持不够：Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</li>
</ul>
<h2 id="Linux2-6的O-1-调度器"><a href="#Linux2-6的O-1-调度器" class="headerlink" title="Linux2.6的O(1)调度器"></a>Linux2.6的O(1)调度器</h2><h3 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h3><pre><code>O(1)调度主要解决可扩展性问题，调度时间为常数
</code></pre><h4 id="普通进程的优先级计算"><a href="#普通进程的优先级计算" class="headerlink" title="普通进程的优先级计算"></a>普通进程的优先级计算</h4><ul>
<li>动态优先级计算公式<br>  dynamic priority = max (100, min ( static priority – bonus +5, 139))<br>  bonus 取决于进程的平均睡眠时间，平均睡眠时间越长，其bonus越大，从而得到更高的优先级。</li>
<li>交互式进程判定公式<br>  dynamic priority ≤ 3 x static priority /4 + 28</li>
</ul>
<h4 id="实时进程的优先级计算"><a href="#实时进程的优先级计算" class="headerlink" title="实时进程的优先级计算"></a>实时进程的优先级计算</h4><p>sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。</p>
<h4 id="O1调度算法"><a href="#O1调度算法" class="headerlink" title="O1调度算法"></a>O1调度算法</h4><ul>
<li>时间片与优先级分离，不再由counter统一表示。时间片用任务描述符中的time_slice域表示，而优先级用prio（普通进程）或者rt_priority（实时进程）表示。</li>
<li>active数组和expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。（数组挂链表结构）</li>
<li>选择进程时，数组下标即为优先级，链表头即为选中的进程，算法复杂度为O(1)</li>
<li>使用bitmap来标记数active数组中是否存在进程，IA处理器提供查询bsf等指令来查询1所在的位置</li>
<li>当进程的时间片减为0时，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组，否则移到expired数组。</li>
<li>当系统判断expire队列进程饥饿时，则强制将active数组中的交互式进程移入expire队列，并互换active和expire队列</li>
</ul>
<h3 id="调度算法的优缺点-1"><a href="#调度算法的优缺点-1" class="headerlink" title="调度算法的优缺点"></a>调度算法的优缺点</h3><ul>
<li>解决了可扩展性的问题，调度时间为常数，与进程数无关</li>
<li>取消了定期更新所有进程counter的操作，优先级的计算分布在各个内核函数中进行</li>
<li>O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢</li>
<li>交互判断以及饥饿判断非常复杂，事实上抵消了pick-next算法的高效性，且公式多为经验值，难以理解</li>
</ul>
<h2 id="CFS-完全公平调度器"><a href="#CFS-完全公平调度器" class="headerlink" title="CFS 完全公平调度器"></a>CFS 完全公平调度器</h2><pre><code>不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。
</code></pre><h3 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h3><pre><code>所有进程按照权重划分CPU时间
</code></pre><ul>
<li>设定一个调度周期（sched_latency_ns），目标是让每个进程在这个周期内至少有机会运行一次</li>
<li>CFS的虚拟时钟每走一步，正在使用CPU的进程i的虚拟时钟也走一步，其他进程的虚拟时钟停止不动</li>
<li>一个进程的权重越大，其虚拟时钟走的越慢。</li>
<li>如果一个进程的虚拟时间走的比CFS的虚拟时钟还慢，说明该进程获得的CPU时间相比自己应该获得的CPU时间少了，在下一个运行周期到来的时候应该给予补偿，优先调度。</li>
</ul>
<h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><ul>
<li>应该分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 </li>
<li>vruntime = 实际运行时间 * NICE_0_LOAD / 进程权重 = (调度周期 * 进程权重 / 所有进程总权重) * NICE_0_LOAD / 进程权重 = 调度周期 * NICE_0_LOAD / 所有进程总权重<br>从上面的公式可知，虽然进程的权重不同，但是它们的vruntime增长速度应该是一样的<br>当我实际执行了n个时间时，CFS虚拟时间应该是多少。当实际运行时间等于应该分配的运行时间时，各个进程的虚拟运行时间是一致的，此时各个进程的调度是完全公平的</li>
</ul>
<h3 id="pick-next算法"><a href="#pick-next算法" class="headerlink" title="pick next算法"></a>pick next算法</h3><pre><code>CFS抛弃了active/expire数组，而使用红黑树选取下一个被调度进程。
</code></pre><p>所有状态为RUNABLE的进程都被插入红黑树。在每个调度点，CFS调度器都会选择红黑树的最左边的叶子节点作为下一个将获得cpu的进程。<br>之所以选择红黑树而没有选择AVL树，是因为红黑树相比AVL树调平衡的成本低，且统计性能很好</p>
<h3 id="tick中断"><a href="#tick中断" class="headerlink" title="tick中断"></a>tick中断</h3><pre><code>理论上每个时钟中断都有可能产生进程切换
</code></pre><p>在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。<br>从这里可以看到CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。<br>虽然每个tick都有切换进程的可能，但不可能允许每个tick都切换进行，系统存在最小调度周期，从而避免了进程抖动</p>
<h4 id="几个重要的细节"><a href="#几个重要的细节" class="headerlink" title="几个重要的细节"></a>几个重要的细节</h4><ol>
<li><p>新进程的vruntime的初值是不是0？<br> 问题：假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。<br> 解决：每个运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以min_vruntime为基础来设置，与老进程保持在合理的差距范围内。</p>
</li>
<li><p>休眠进程的vruntime一直保持不变吗？<br> 问题：如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。<br> 解决：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。</p>
</li>
<li><p>休眠进程在唤醒时会立刻抢占CPU吗？<br> 问题：由于休眠进程在唤醒时会获得vruntime的补偿，所以它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。但除了交互式进程以外，主动休眠的进程同样也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这类进程往往并不要求快速响应，但是CFS不会把它们与交互式进程区分开来，它们同样也会在每次唤醒时获得vruntime补偿，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。<br> 解决：这可以由CFS的唤醒抢占特性解决，即sched_features的WAKEUP_PREEMPT位。CFS可以禁止唤醒抢占特性。如果禁止唤醒抢占特性对你的系统来说太过激进的话，还可以选择调大以下参数：sched_wakeup_granularity_ns，这个参数限定了一个唤醒进程要抢占当前进程之前必须满足的条件：只有当该唤醒进程的vruntime比当前进程的vruntime小、并且两者差距(vdiff)大于sched_wakeup_granularity_ns的情况下，才可以抢占，否则不可以。这个参数越大，发生唤醒抢占就越不容易。</p>
</li>
<li><p>进程占用的CPU时间片可以无穷小吗？<br> 问题：假设有两个进程，它们的vruntime初值都是一样的，第一个进程只要一运行，它的vruntime马上就比第二个进程更大了，那么它的CPU会立即被第二个进程抢占吗？<br> 解决：为了避免过于短暂的进程切换造成太大的消耗，CFS设定了进程占用CPU的最小时间值，sched_min_granularity_ns，正在CPU上运行的进程如果不足这个时间是不可以被调离CPU的。另外，当进程过多时，调度周期也不再遵守sched_latency_ns，而是以 (sched_min_granularity_ns * 进程数量) 的乘积为准</p>
</li>
<li><p>进程从一个CPU迁移到另一个CPU上的时候vruntime会不会变？<br> 问题：如果一个进程从min_vruntime更小的CPU (A) 上迁移到min_vruntime更大的CPU (B) 上，可能就会占便宜了，因为CPU (B) 的运行队列中进程的vruntime普遍比较大，迁移过来的进程就会获得更多的CPU时间片。这显然不太公平。<br> 解决：当进程从一个CPU的运行队列中出来 (dequeue_entity) 的时候，它的vruntime要减去队列的min_vruntime值；而当进程加入另一个CPU的运行队列 ( enqueue_entiry) 时，它的vruntime要加上该队列的min_vruntime值。这样，进程从一个CPU迁移到另一个CPU之后，vruntime保持相对公平。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/12/linux-process-scheduling/" data-id="cjca19cu00001nu08c46sfkcs" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scheduling/">Scheduling</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/11/hexo-getting-started/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Github+Hexo基础环境（for Mac）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/">Tutorial</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheduling/">Scheduling</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Scheduling/" style="font-size: 10px;">Scheduling</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/12/linux-process-scheduling/">Linux进程调度</a>
          </li>
        
          <li>
            <a href="/2018/01/11/hexo-getting-started/">Github+Hexo基础环境（for Mac）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 ELwin.Gao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>