title: Linux进程调度
date: 2015-11-16 23:18:54
categories: undefined
tags: Linux-Kernel
---
# Linux进程分类

### 交互式进程
此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。

### 批处理进程
此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。

### 实时进程
实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件

# 内核调度器的演变

## Linux2.4 的调度器

### 设计思路
	RunQueue + 时间片 + 优先级
对 runqueue（全局唯一的就绪队列） 中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。
每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。
Linux2.4 调度器保证只有当所有 RUNNING 进程的时间片都被用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行。

#### 实时进程
	静态优先级
实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当 runqueue 中没有实时进程的情况下，普通进程才能够获得调度。
实时进程采用两种调度策略：
* SCHED\_FIFO采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度
* SCHED\_RR(Round Robin) 采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。

#### 普通进程
	counter（时间片）越大，优先级越高
普通进程的优先级主要由进程描述符中的 Counter 字段决定 (还要加上 nice 设定的静态优先级) 。
nice从最初的UNIX沿用而来，表示进程的静态负向优先级，其取值范围为19~-20，以-20优先级最高。
进程被创建时子进程的 counter 值为父进程 counter 值的一半，这样保证了任何进程不能依靠不断地 fork() 子进程从而获得更多的执行机会。
当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。系统通过这种方式提高交互式进程的相应速度。

### 调度算法的优缺点
* 可扩展性不好：无论pick next，还是更新counter，系统开销都是根据进程数线性增长
* 高负载系统上的调度性能比较低：2.4的调度器预分配给每个进程的时间片比较大，这就导致了在高负载系统上，任何一个进程被调度到通常至少要等待一个时间片（一般是10ms）
* 交互式进程的优化并不完善：无法区分IO等待和交互等待，当系统进行IO密集型作业时，由于大量的IO等待，这些作业虽然不是交互式作业，但依旧被提高了优先级，从而影响到真正的交互式作业。
* 对实时进程的支持不够：Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。

## Linux2.6的O(1)调度器

### 设计思路
	O(1)调度主要解决可扩展性问题，调度时间为常数

#### 普通进程的优先级计算

* 动态优先级计算公式
	dynamic priority = max (100, min ( static priority – bonus +5, 139))
	bonus 取决于进程的平均睡眠时间，平均睡眠时间越长，其bonus越大，从而得到更高的优先级。
* 交互式进程判定公式
	dynamic priority ≤ 3 x static priority /4 + 28

#### 实时进程的优先级计算
sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。

#### O1调度算法
* 时间片与优先级分离，不再由counter统一表示。时间片用任务描述符中的time\_slice域表示，而优先级用prio（普通进程）或者rt\_priority（实时进程）表示。
* active数组和expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。（数组挂链表结构）
* 选择进程时，数组下标即为优先级，链表头即为选中的进程，算法复杂度为O(1)
* 使用bitmap来标记数active数组中是否存在进程，IA处理器提供查询bsf等指令来查询1所在的位置
* 当进程的时间片减为0时，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组，否则移到expired数组。
* 当系统判断expire队列进程饥饿时，则强制将active数组中的交互式进程移入expire队列，并互换active和expire队列

### 调度算法的优缺点
* 解决了可扩展性的问题，调度时间为常数，与进程数无关
* 取消了定期更新所有进程counter的操作，优先级的计算分布在各个内核函数中进行
* O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢
* 交互判断以及饥饿判断非常复杂，事实上抵消了pick-next算法的高效性，且公式多为经验值，难以理解

## CFS 完全公平调度器
	不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。

### 设计思路
	所有进程按照权重划分CPU时间
* 设定一个调度周期（sched\_latency\_ns），目标是让每个进程在这个周期内至少有机会运行一次
* CFS的虚拟时钟每走一步，正在使用CPU的进程i的虚拟时钟也走一步，其他进程的虚拟时钟停止不动
* 一个进程的权重越大，其虚拟时钟走的越慢。
* 如果一个进程的虚拟时间走的比CFS的虚拟时钟还慢，说明该进程获得的CPU时间相比自己应该获得的CPU时间少了，在下一个运行周期到来的时候应该给予补偿，优先调度。

### 计算公式
* 应该分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 
* vruntime = 实际运行时间 \* NICE\_0\_LOAD / 进程权重 = (调度周期 \* 进程权重 / 所有进程总权重) \* NICE\_0\_LOAD / 进程权重 = 调度周期 \* NICE\_0\_LOAD / 所有进程总权重
从上面的公式可知，虽然进程的权重不同，但是它们的vruntime增长速度应该是一样的
当我实际执行了n个时间时，CFS虚拟时间应该是多少。当实际运行时间等于应该分配的运行时间时，各个进程的虚拟运行时间是一致的，此时各个进程的调度是完全公平的

### pick next算法
	CFS抛弃了active/expire数组，而使用红黑树选取下一个被调度进程。
所有状态为RUNABLE的进程都被插入红黑树。在每个调度点，CFS调度器都会选择红黑树的最左边的叶子节点作为下一个将获得cpu的进程。
之所以选择红黑树而没有选择AVL树，是因为红黑树相比AVL树调平衡的成本低，且统计性能很好

### tick中断
	理论上每个时钟中断都有可能产生进程切换
在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。
从这里可以看到CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。
虽然每个tick都有切换进程的可能，但不可能允许每个tick都切换进行，系统存在最小调度周期，从而避免了进程抖动

#### 几个重要的细节
1. 新进程的vruntime的初值是不是0？
	问题：假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。
	解决：每个运行队列cfs\_rq都维护一个min\_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以min_vruntime为基础来设置，与老进程保持在合理的差距范围内。

2. 休眠进程的vruntime一直保持不变吗？
	问题：如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。
	解决：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。

3. 休眠进程在唤醒时会立刻抢占CPU吗？
	问题：由于休眠进程在唤醒时会获得vruntime的补偿，所以它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。但除了交互式进程以外，主动休眠的进程同样也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这类进程往往并不要求快速响应，但是CFS不会把它们与交互式进程区分开来，它们同样也会在每次唤醒时获得vruntime补偿，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。
	解决：这可以由CFS的唤醒抢占特性解决，即sched\_features的WAKEUP\_PREEMPT位。CFS可以禁止唤醒抢占特性。如果禁止唤醒抢占特性对你的系统来说太过激进的话，还可以选择调大以下参数：sched\_wakeup\_granularity\_ns，这个参数限定了一个唤醒进程要抢占当前进程之前必须满足的条件：只有当该唤醒进程的vruntime比当前进程的vruntime小、并且两者差距(vdiff)大于sched_wakeup_granularity_ns的情况下，才可以抢占，否则不可以。这个参数越大，发生唤醒抢占就越不容易。

4. 进程占用的CPU时间片可以无穷小吗？
	问题：假设有两个进程，它们的vruntime初值都是一样的，第一个进程只要一运行，它的vruntime马上就比第二个进程更大了，那么它的CPU会立即被第二个进程抢占吗？
	解决：为了避免过于短暂的进程切换造成太大的消耗，CFS设定了进程占用CPU的最小时间值，sched\_min\_granularity\_ns，正在CPU上运行的进程如果不足这个时间是不可以被调离CPU的。另外，当进程过多时，调度周期也不再遵守sched_latency_ns，而是以 (sched\_min\_granularity\_ns * 进程数量) 的乘积为准

5. 进程从一个CPU迁移到另一个CPU上的时候vruntime会不会变？
	问题：如果一个进程从min\_vruntime更小的CPU (A) 上迁移到min\_vruntime更大的CPU (B) 上，可能就会占便宜了，因为CPU (B) 的运行队列中进程的vruntime普遍比较大，迁移过来的进程就会获得更多的CPU时间片。这显然不太公平。
	解决：当进程从一个CPU的运行队列中出来 (dequeue\_entity) 的时候，它的vruntime要减去队列的min\_vruntime值；而当进程加入另一个CPU的运行队列 ( enqueue\_entiry) 时，它的vruntime要加上该队列的min\_vruntime值。这样，进程从一个CPU迁移到另一个CPU之后，vruntime保持相对公平。

